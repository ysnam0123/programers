<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //push : 배열의 맨 끝에 요소를 추가
        let fruits_push = ['사과','바나나','체리'];
        fruits_push.push('포도')
        console.log(fruits_push) //사과,바나나, 체리, 포도
        fruits_push.push('딸기','복숭아')
        console.log(fruits_push)// ['사과', '바나나', '체리', '포도', '딸기', '복숭아']
    </script>
      
      <script>
        //pop :  마지막 요소를 제거
        let fruits_pop = ['사과','바나나','체리','포도'];

        let removefruits = fruits_pop.pop();
        console.log(removefruits)//포도
        console.log(fruits_pop)//['사과','바나나','체리']

        removefruits = fruits_pop.pop();
        console.log(removefruits)//'체리'
        console.log(fruits_pop)//['사과','바나나']
      </script>

      <script>
        //unshift : 배열의 맨 앞쪽에 요소를 추가
        let numbers =[2,3,4]
        numbers.unshift(1)
        console.log(numbers)//[1, 2, 3, 4]
        numbers.unshift(-2,-1,0)
        console.log(numbers)//[-2,-1,0,1, 2, 3, 4]
      </script>

      <script>
        //shift : 첫번째 요소를 제거

        let animals = ['강아지','고양이','토끼','기린'];
        let removeanimals =  animals.shift();
        console.log(animals)//['고양이','토끼','기린']
        console.log(removeanimals)//'강아지'

        removeanimals =  animals.shift();
        console.log(animals)//['토끼','기린']
        console.log(removeanimals)//'고양이

      </script>

      <script>
            //map :  배열의 요소를 순회하면서 제공된 콜백 함수를 적용하여 새로운 배열을 생성
            //! 원본 배열은 변형되지 않고  항상 새로운 배열을 반환
        //숫자 배열
            const numbers_map = [1,2,3,4,5];
            const squaredNumbers =  numbers_map.map(num => num *num);
            console.log(squaredNumbers)//[1,4,9,16,25]
        //문자열 배열
            const names = ['홍길동','홍길자','홍길순'];
            const politeNames =  names.map(name =>`${name}님`)
            console.log(politeNames)//[홍길동님, 홍길자님, 홍길순님]

      </script>
       

       <script>
          //filter : 조건에 맞는 요소를 찾아서  반환

          const numbers_filter =[10,25,33,47,58,61]
          const evenNumbers =  numbers_filter.filter(num =>num %2 ===0)
          console.log(evenNumbers)//[10,58]


          const students =[
            {name:'홍길동',score : 85},
            {name:'홍길자',score : 60},
            {name:'홍길순',score : 90},
            {name:'홍길수',score : 70}
          ]
           const highScore =  students.filter(student =>student.score >= 80);
           console.log(highScore)
       </script>

       <script>
        //sort : 요소를 정렬
        
         const numbers_sort = [10,8,1,5,7];
         numbers_sort.sort((a,b) =>a - b);
         console.log('오름차순정렬 : ',numbers_sort)//1,5,7,8,10

        numbers_sort.sort((a,b) =>b - a);
         console.log('내림차순정렬 : ',numbers_sort)//10,8,7,5,1

         const fruits =  ['바나나','사과','체리','포도']
         fruits.sort()
         console.log('알파벳순정렬 : ',fruits)//['바나나','사과','체리','포도']

         fruits.sort((a,b) =>a.length - b.length)
         console.log('문자열 길이순 : ',fruits)//['사과','체리','포도','바나나']

       </script>

       <script>
        //reverse  : 배열의 요소 순서를 뒤집어서 반환
        const numbers_reverse = [10,20,30,40,50]
        numbers_reverse.reverse();
        console.log(numbers_reverse)//[50,40,30,20,10]

        const words = ['안녕하세요','세번째 시간입니다','배열입니다']
        words.reverse()
        console.log(words)//['배열입니다', '세번째 시간입니다', '안녕하세요']
       </script>


       <script>
        //join : 배열의 요소를 하나의 문자열로 합쳐서 반환

        const numbers_join =[1,2,3,4,5];
        const numbersString = numbers_join.join(', ')
        console.log(numbersString)//1,2,3,4,5

        const words_join = ['안녕하세요','세번째 시간입니다','배열입니다']
        const wordsList = words_join.join(', ')
        console.log(wordsList);//안녕하세요, 세번째 시간입니다, 배열입니다
       </script>

       <script>
         //split() :배열은 아님
         //문자열을 특정 구분자(공백, 쉼표)기준으로 나누어서 배열로 반환

         const sentence_split = '안녕하세요. 배열을 학습하고 있습니다.'
         const words_split = sentence_split.split(" ")
         console.log(words_split);//['안녕하세요.','배열을','학습하고','있습니다.']

         const csv ="사과,바나나,딸기, 포도"
         const fruits_split = csv.split(',')
         console.log(fruits_split)//['사과','바나나','딸기','포토']

         const characters =  "안녕하세요".split('');
         console.log(characters)//['안', '녕', '하', '세', '요']
       </script>

       <script>
        //reduce

        const shoppingList =[
            {item:'우유',price:2000},
            {item:'빵',price:3000},
            {item:'사과',price:1500},
        ]

        const totalPrice =  shoppingList.reduce((acc, current) =>acc + current.price,0);
        //acc 누적값(현재까지 계산된값),curent(현재처리중인 배열항목),0 초기값
        console.log(totalPrice)//6500

       </script>

       <script>
        //스프레드 문법(스프레드 연산자 ...) : 데이터를 개별요소로 분해하거나 복사 할때

        //배열에서 스프레드 연산자
        const numbers_spread = [1,2,3]
        const newNumbers = [...numbers_spread,4,5]
        console.log(newNumbers)//[1,2,3,4,5]

        //객체에서 스프레드 연산자
        const person = {name : '홍길동 ', age:25};
        const updatePerson ={...person, job:'개발자'};
        console.log(updatePerson);//{name: '홍길동 ', age: 25, job: '개발자'}

        //함수에 스프레드 연산자로 함수인자 분해
        function sum(a,b,c){
            return a+b+c
        }
        const values =[10,20,30];
        console.log(sum(...values))//60
        //...values의 배열값[10,20,30]의 요소를 각각의 함수의 인자 a,b,c로 분해하여 전달

        //배열복사본은 독립적인 배열
        const original =[1,2,3]
        const copy = [...original]
        console.log(copy)//[1, 2, 3]
        console.log(original === copy)//false 복사본은 원본과 독립적인 배열이다
       </script>
</body>
</html>